(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[8007],{6633:(n,s,e)=>{"use strict";e.r(s),e.d(s,{data:()=>a});const a={key:"v-76f750fc",path:"/pages/fe-sre/docker/",title:"",lang:"zh-CN",frontmatter:{home:!1},excerpt:"",headers:[{level:2,title:"docker 实用笔记",slug:"docker-实用笔记",children:[{level:3,title:"docker 常用指令",slug:"docker-常用指令",children:[]},{level:3,title:"Dockerfile",slug:"dockerfile",children:[]},{level:3,title:".dockerignore",slug:"dockerignore",children:[]},{level:3,title:"Docker Compose",slug:"docker-compose",children:[]},{level:3,title:"常见错误",slug:"常见错误",children:[]},{level:3,title:"何时不使用 Docker",slug:"何时不使用-docker",children:[]}]}],filePathRelative:"pages/fe-sre/docker/README.md",git:{updatedTime:1726747499e3,contributors:[{name:"COOKIES-LGL",email:"1344714332@qq.com",commits:9}]}}},3836:(n,s,e)=>{"use strict";e.r(s),e.d(s,{default:()=>_});var a=e(6252);const l=(0,a.Wm)("h2",{id:"docker-实用笔记"},[(0,a.Wm)("a",{class:"header-anchor",href:"#docker-实用笔记"},"#"),(0,a.Uk)(" docker 实用笔记")],-1),p={href:"https://juejin.cn/column/6965049243660714021",target:"_blank",rel:"noopener noreferrer"},r=(0,a.Uk)("面向 WEB 开发人员的 Docker"),c=(0,a.uE)('<h3 id="docker-常用指令"><a class="header-anchor" href="#docker-常用指令">#</a> docker 常用指令</h3><p>Docker 可用于在任何开发 PC 上提供可复制的构建环境。</p><p>Docker 使用了缓存来加速镜像构建，所以上面执行结果可以看出只要上一层和当前层的输入没有变动，那么执行结果就会被缓存下来。</p><p>docker run 提供了许多选项，但是将使用的主要选项是：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>-d：运行一个容器作为后台进程（在应用程序结束时退出）\n-it：保持容器在前台运行（即使在应用程序结束后），并显示活动日志\n--rm ：停止后取出容器\n--name：命名容器（否则使用随机GUID）\n-p：将主机端口映射到容器端口\n--mount：创建一个持久的docker管理卷来保存数据。字符串指定一个src卷名和一个target，在容器的文件系统中装入卷名\n-v：使用符号挂载主机文件夹: <span class="token environment constant">$PWD</span>/data （当前命令所在目录/data）\n-e：定义环境变量\n--env-file：从文件中读取环境变量，其中每行定义一个VAR<span class="token operator">=</span>value\n--net：连接到特定的Docker网络\n--entrypoint ：覆盖默认的启动应用程序\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker inspect mysql\n<span class="token comment"># 返回JSON格式的容器信息</span>\ndocker container <span class="token function">ls</span> -a\n<span class="token comment"># 查看正在运行的容器的列表</span>\ndocker <span class="token function">ps</span>\n<span class="token comment"># 查看正在运行的容器的列表</span>\ndocker system <span class="token function">df</span>\n<span class="token comment"># 获得磁盘使用情况统计信息</span>\ndocker volume <span class="token function">ls</span>\n<span class="token comment"># 查看所有Docker管理的磁盘卷</span>\ndocker network <span class="token function">ls</span>\n<span class="token comment"># 查看所有Docker网络</span>\ndocker <span class="token builtin class-name">exec</span> -it cd7b5d5bb5e8 <span class="token function">bash</span>\n<span class="token comment"># 进入容器cd7b5d5bb5e8</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p><strong>自定义 docker 网络</strong> 创建自己的 Docker 网络</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker network create --driver bridge mysqlNet\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run\n  -d --rm --name mysql\n  -p <span class="token number">3306</span>:3306\n  --mount <span class="token string">&quot;src=mysqldata,target=/var/lib/mysql&quot;</span>\n  -e <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span>websecret\n  --net mysqlNet\n  mysql\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run\n  -d --rm --name adminer\n  -p <span class="token number">8080</span>:8080\n  --net mysqlNet\n  adminer\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="dockerfile"><a class="header-anchor" href="#dockerfile">#</a> Dockerfile</h3><p>Dockerfile 中执行各种任务，包括环境初始化、单元测试、构建</p><p>使用 Dockerfile 配置映像。它定义：</p><ul><li>起始基本映像，通常是操作系统</li><li>工作目录和用户权限</li><li>所有必要的安装步骤，例如定义环境变量，从主机复制文件，运行安装过程等。</li><li>容器是否应附加一个或多个卷以进行数据存储</li><li>容器是否应加入网络以与他人通信</li><li>主机上公开了哪些端口（如果有） localhost</li><li>应用程序启动命令。</li></ul><p>Dockerfile 就是这样一个用于描述 Docker 镜像构建过程的文本文件，这个文件可以包含多条构建指令，以及相关的描述</p><div class="language-yaml ext-yml line-numbers-mode"><pre class="language-yaml"><code><span class="token comment"># 基于 Node.js 的 lts镜像</span>\nFROM node<span class="token punctuation">:</span>lts<span class="token punctuation">-</span>alpine\n\n<span class="token comment"># 定义环境变量</span>\nENV WORKDIR=/data/node/app\nENV NODE_ENV=production\nENV NODE_PORT=3005\n\n<span class="token comment"># 创建应用程序文件夹并分配权限给 node 用户</span>\nRUN mkdir <span class="token punctuation">-</span>p $WORKDIR <span class="token important">&amp;&amp;</span> chown <span class="token punctuation">-</span>R node<span class="token punctuation">:</span>node $WORKDIR\n\n<span class="token comment"># 设置工作目录</span>\nWORKDIR $WORKDIR\n\n<span class="token comment"># 设置活动用户</span>\nUSER node\n\n<span class="token comment"># 复制 package.json 到工作目录</span>\nCOPY <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=node<span class="token punctuation">:</span>node package.json $WORKDIR/\n\n<span class="token comment"># 安装依赖</span>\nRUN npm install <span class="token important">&amp;&amp;</span> npm cache clean <span class="token punctuation">-</span><span class="token punctuation">-</span>force\n\n<span class="token comment"># 复制其他文件</span>\nCOPY <span class="token punctuation">-</span><span class="token punctuation">-</span>chown=node<span class="token punctuation">:</span>node . .\n\n<span class="token comment"># 暴露主机端口</span>\nEXPOSE $NODE_PORT\n\n<span class="token comment"># 应用程序启动命令</span>\nCMD <span class="token punctuation">[</span> <span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;./index.js&quot;</span> <span class="token punctuation">]</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div>',16),o={href:"https://juejin.cn/post/7179042892395053113?searchId=20240723114156ADF38CC477C06B958D85",target:"_blank",rel:"noopener noreferrer"},i=(0,a.Uk)("Dockerfile 文件详解"),t={href:"https://juejin.cn/post/7269668219488354361?searchId=20240723155610C04B85D6CEF8063CAB10",target:"_blank",rel:"noopener noreferrer"},u=(0,a.Uk)("Dockerfile 赋能前端部署"),m=(0,a.uE)('<hr><h3 id="dockerignore"><a class="header-anchor" href="#dockerignore">#</a> .dockerignore</h3><ul><li>减少构建上下文的大小，因为不需要将所有文件发送到 Docker 守护进程。</li><li>加速构建过程，因为 Docker 不需要处理不必要的文件。</li><li>保护敏感数据，如本地配置文件或源代码，不会意外地包含在镜像中。</li></ul><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 忽略 node_modules 目录</span>\nnode_modules/\n<span class="token comment"># 忽略 git 信息</span>\n.git\n<span class="token comment"># 忽略 IDE 设置</span>\n.vscode/\n<span class="token comment"># 忽略本地配置文件</span>\nconfig/local.js\n<span class="token comment"># 忽略日志文件</span>\nlogs/\n<span class="token comment"># 忽略构建产物</span>\ndist/\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><hr><h3 id="docker-compose"><a class="header-anchor" href="#docker-compose">#</a> Docker Compose</h3><p>Docker Compose 允许您在单个 YAML 文件中定义和管理多容器应用程序。这简化了编排和协调各种服务的复杂任务，使管理和复制应用程序环境变得更加容易。</p><ol><li><p>docker-compose up - 启动服务。</p><ul><li>-d 参数可以在后台启动服务：docker-compose up -d。</li><li>--build 参数可以在启动服务前重新构建镜像：docker-compose up --build。</li></ul></li><li><p>docker-compose down - 停止服务并删除容器、网络和卷。</p></li><li><p>docker-compose start - 启动服务。</p></li><li><p>docker-compose stop - 停止服务。</p></li><li><p>docker-compose restart - 重启服务。</p></li><li><p>docker-compose ps - 列出所有容器。</p></li><li><p>docker-compose exec <code>&lt;service&gt;</code> - 进入指定服务的容器。</p><ul><li>例如：docker-compose exec web /bin/bash。</li></ul></li><li><p>docker-compose logs - 查看服务的日志。</p></li><li><p>docker-compose config - 验证和查看 Compose 文件的配置。</p></li><li><p>docker-compose build - 构建或重新构建服务的镜像。</p></li><li><p>docker-compose pull - 拉取服务的镜像。</p></li><li><p>docker-compose push - 推送服务的镜像。</p></li><li><p>docker-compose rm - 删除停止的服务容器。</p></li><li><p>docker-compose scale - 设置服务的容器数量。例如：docker-compose scale web=3。</p></li><li><p>docker-compose version - 显示版本信息。</p></li></ol><h4 id="docker-yml-文件说明"><a class="header-anchor" href="#docker-yml-文件说明">#</a> docker.yml 文件说明</h4><ul><li><p>Docker 是一种轻量级的容器化技术，用于将应用程序及其依赖项打包为一个可移植的容器。</p></li><li><p>Docker Compose 是 Docker 官方推出的一个用于定义和运行多容器 Docker 应用程序的工具。</p></li><li><p>Docker Compose 使用一个名为 docker-compose.yml 的文件来配置应用程序的服务。 下面详细解释 Docker yml 文件的结构和使用方法。可以在必要时覆盖 Dockerfile 设置<br> 一个典型的 Docker Compose yml 文件包含如下几个部分：</p></li><li><p>version：指定 Docker Compose 文件的版本号。</p></li><li><p>services：定义各个服务的容器配置。</p></li><li><p>networks：定义应用程序的网络配置。</p></li><li><p>volumes：定义应用程序的卷配置。</p></li></ul><p>在 Docker Compose yml 文件中，常用的配置项包括：</p><ol><li>image：指定容器使用的镜像。</li><li>build：指定 Dockerfile 的路径，用于构建自定义镜像。</li><li>ports：定义端口映射关系。</li><li>volumes：定义卷映射关系。</li><li>environment：设置环境变量。</li><li>networks：定义网络配置。。</li><li>depends_on：定义服务之间的依赖关系。</li><li>restart：指定服务的重启策略。</li></ol><div class="language-yaml ext-yml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">restart</span><span class="token punctuation">:</span> <span class="token string">&quot;no&quot;</span>\n<span class="token comment"># no是默认的重启策略，在任何情况下都不会重启容器</span>\n<span class="token key atrule">restart</span><span class="token punctuation">:</span> always\n<span class="token comment"># always指定时，容器总是重新启动</span>\n<span class="token key atrule">restart</span><span class="token punctuation">:</span> on<span class="token punctuation">-</span>failure\n<span class="token comment"># on-failure如果退出代码指示失败错误，则该策略会重新启动容器</span>\n<span class="token key atrule">restart</span><span class="token punctuation">:</span> unless<span class="token punctuation">-</span>stopped\n<span class="token comment"># unless-stopped总是重新启动容器，除非容器停止（手动或其他方式</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div>',13),b={href:"https://www.cnblogs.com/dirgo/p/18112035",target:"_blank",rel:"noopener noreferrer"},k=(0,a.Uk)("全部配置项说明"),d=(0,a.Wm)("p",null,"管理，扩展和维护容器的过程称为业务流程,Docker Compose 可以用于基本的编排，但是最好使用专业工具，",-1),h=(0,a.Wm)("blockquote",null,[(0,a.Wm)("p",null,"Docker Swarm Kubernetes")],-1),g=(0,a.Wm)("hr",null,null,-1),v=(0,a.Wm)("h3",{id:"常见错误"},[(0,a.Wm)("a",{class:"header-anchor",href:"#常见错误"},"#"),(0,a.Uk)(" 常见错误")],-1),D=(0,a.Wm)("blockquote",null,[(0,a.Wm)("p",null,"Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?")],-1),f=(0,a.Wm)("p",null,"运行 docker compose 遇到上述报错时需要重新启动 docker 服务",-1),y=(0,a.Wm)("hr",null,null,-1),W=(0,a.Wm)("blockquote",null,[(0,a.Wm)("p",null,"拉取 Docker 镜像时，如果遇到“error getting credentials - err: exit status 1, out: ``")],-1),R=(0,a.Uk)("这通常意味着 Docker 客户端无法获取到需要的认证信息来访问 Docker Hub 或其他镜像仓库，"),C=(0,a.Wm)("code",null,"需要登录docker hub",-1),w=(0,a.Uk)(),q={href:"https://www.docker.com",target:"_blank",rel:"noopener noreferrer"},O=(0,a.Uk)("进入 Docker 官网"),E=(0,a.Uk)("注册。"),x=(0,a.uE)('<hr><blockquote><p>no matching manifest for linux/arm64/v8 in the manifest list entries ELIFECYCLE  Command failed with exit code 18. Docker 镜像可能包含多个架构的变体。当客户端尝试拉取针对特定架构（比如 arm64 或者 v8，这是 ARM 架构的一种说法）的镜像时，如果服务器上没有对应架构的镜像，就会出现这个错误 你知道你的系统架构，你可以使用 docker run 命令的--platform 选项指定要运行的特定架构的镜像</p></blockquote><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>docker run --platform<span class="token operator">=</span>linux/arm64/v8 <span class="token operator">&lt;</span>image-name<span class="token operator">&gt;</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>对于 docker compose 运行方式 配置 yml 文件的 platform 字段，可以指定要运行的架构。</p><div class="language-yaml ext-yml line-numbers-mode"><pre class="language-yaml"><code><span class="token key atrule">services</span><span class="token punctuation">:</span>\n  <span class="token key atrule">redis</span><span class="token punctuation">:</span>\n    <span class="token key atrule">image</span><span class="token punctuation">:</span> redis<span class="token punctuation">:</span>alpine\n    <span class="token key atrule">platform</span><span class="token punctuation">:</span> linux/x86_64\n    <span class="token key atrule">container_name</span><span class="token punctuation">:</span> nest<span class="token punctuation">-</span>admin<span class="token punctuation">-</span>redis\n    <span class="token key atrule">restart</span><span class="token punctuation">:</span> always\n    <span class="token key atrule">env_file</span><span class="token punctuation">:</span>\n      <span class="token punctuation">-</span> .env\n      <span class="token punctuation">-</span> .env.production\n    <span class="token key atrule">ports</span><span class="token punctuation">:</span>\n      <span class="token punctuation">-</span> <span class="token string">&quot;${REDIS_PORT}:6379&quot;</span>\n    <span class="token key atrule">command</span><span class="token punctuation">:</span> <span class="token punctuation">&gt;</span><span class="token scalar string">\n      --requirepass ${REDIS_PASSWORD}</span>\n    <span class="token key atrule">networks</span><span class="token punctuation">:</span>\n      <span class="token punctuation">-</span> nest_admin_net\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="何时不使用-docker"><a class="header-anchor" href="#何时不使用-docker">#</a> 何时不使用 Docker</h3><ol><li>应用程序不是无状态的</li><li>正在使用 Windows Server</li><li>Docker 容器已施加 CPU 和 RAM 限制, 性能比原生 OS 慢</li><li>Docker 容器是隔离的，但是与真实的 VM 不同，容器没有从主机 OS 完全沙盒化.它不能替代强大的安全性.</li></ol>',7),_={render:function(n,s){const e=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.j4)(a.HY,null,[l,(0,a.Wm)("p",null,[(0,a.Wm)("a",p,[r,(0,a.Wm)(e)])]),c,(0,a.Wm)("p",null,[(0,a.Wm)("a",o,[i,(0,a.Wm)(e)]),(0,a.Wm)("a",t,[u,(0,a.Wm)(e)])]),m,(0,a.Wm)("p",null,[(0,a.Wm)("a",b,[k,(0,a.Wm)(e)])]),d,h,g,v,D,f,y,W,(0,a.Wm)("p",null,[R,C,w,(0,a.Wm)("a",q,[O,(0,a.Wm)(e)]),E]),x],64)}}}}]);