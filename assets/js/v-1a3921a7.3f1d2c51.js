(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[1066],{6836:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>e});const e={key:"v-1a3921a7",path:"/pages/fe-sre/monorepo/",title:"",lang:"zh-CN",frontmatter:{home:!1,sidebar:!1},excerpt:"",headers:[{level:3,title:"使用 monorepo 的原因",slug:"使用-monorepo-的原因",children:[]},{level:3,title:"Mono-repo、Mult-repo",slug:"mono-repo、mult-repo",children:[]},{level:3,title:"multrepo 与 monorepo 优缺点",slug:"multrepo-与-monorepo-优缺点",children:[]},{level:3,title:"创建一个 monorepo",slug:"创建一个-monorepo",children:[]},{level:3,title:"with proxy 代理",slug:"with-proxy-代理",children:[]},{level:3,title:"yarn workspaces",slug:"yarn-workspaces",children:[]}],filePathRelative:"pages/fe-sre/monorepo/README.md",git:{updatedTime:1743562444e3,contributors:[{name:"COOKIES-LGL",email:"1344714332@qq.com",commits:12},{name:"guilin.li",email:"1344714332@qq.com",commits:2}]}}},830:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>u});var e=a(6252);const p={href:"https://zhuanlan.zhihu.com/p/414468874",target:"_blank",rel:"noopener noreferrer"},o=(0,e.Uk)("微服务架构乾坤核心原理"),t=(0,e.uE)('<h3 id="使用-monorepo-的原因"><a class="header-anchor" href="#使用-monorepo-的原因">#</a> 使用 monorepo 的原因</h3><p>我正在开发的项目 A，依赖了已经线上发布的项目 B，但是随着项目 A 的不断开发，又需要不时修改项目 B 的代码（这些修改暂时不必发布线上），如何能够在修改项目 B 代码后及时将改动后在项目 A 中同步？ 在项目 A 发布上线后，如何以一种优雅的方式解决项目 A，B 版本升级后的版本同步问题？</p><h3 id="mono-repo、mult-repo"><a class="header-anchor" href="#mono-repo、mult-repo">#</a> Mono-repo、Mult-repo</h3><p>在 mono-repo 方法中，你可以将所有服务保存在单一(mono)存储库中。你仍然可以独立地部署和管理每个服务。这些服务可以共享公共库和代码。</p><p>1、Mono-repo 的优势 Mon-repo 方式有许多优点：</p><ul><li>存储所有项目代码的单独位置，团队中的每个人都可以访问。</li><li>易于重用和共享代码，与团队合作。</li><li>很容易理解你的变更对整个项目的影响。</li><li>代码重构和代码大变更的最佳选择。</li><li>团队成员可以获得整个项目的总体视图。</li><li>易于管理依赖关系。</li></ul><p>2、Mono-repo 的劣势 当然，Mono-repo 也有一些缺点，</p><ul><li>主要表现在性能上。如果你的项目增长，每隔一天都会添加更多的文件，那么 git checkout、pull 和其他操作可能变得缓慢，以及文件搜索可能需要更长的时间。</li><li>此外，如果你为你的项目雇佣了许多独立的承包商，那么让他们访问整个代码库可能不那么安全。</li><li>此外，实现持续部署(Continuous deployation，CD)也很困难，因为许多人可以合入他们的更改，而持续集成(Continuous Integration，CI)系统可能需要进行多次重构。</li></ul><p>使用 Mono-repo 的大公司都有自定义工具来处理扩展问题。例如，Facebook 使用自定义文件系统和源代码控制。</p><p>什么是 Multi-repo?<br> 在 Multi-repo 方法中，存在多个存储库，它们承载一个项目的多个库和服务。如果服务发生更改，开发人员只需重新构建该服务，而不需要构建整个项目。个人和团队可以从事他们特定的服务，他们只能访问他们有权限的服务。</p><p>1、Multi-repo 的优势 采用 Multi-repo 的公司数量远远多于采用 Mono-repo 的公司，原因如下:</p><ul><li>每个服务和库都有自己的版本控制。</li><li>代码 checkout 和 pull 是小型且独立的，因此即使项目规模增大，也不存在性能问题。</li><li>团队可以独立工作，不需要访问整个代码库。</li><li>更快的开发和灵活性。</li><li>每个服务都可以单独发版，并有自己的部署周期，从而使 CI 和 CD 更易于实现。</li><li>更好的权限访问控制——所有的团队不需要完全访问所有的库——需要的时候，再获得读访问权限。 2、Multi-repo 的劣势</li></ul><ol><li>跨服务和项目使用的公共依赖和库必须定期同步以获得最新版本。</li><li>某种程度上鼓励孤立文化，导致重复代码和各个团队试图解决相同问题。</li><li>每个团队可能遵循不同的一组最佳实践来编写代码，从而导致难以遵循通用的最佳实践。</li></ol><h3 id="multrepo-与-monorepo-优缺点"><a class="header-anchor" href="#multrepo-与-monorepo-优缺点">#</a> multrepo 与 monorepo 优缺点</h3><img src="http://upload-images.jianshu.io/upload_images/19806861-7e0ab233b65060e2.png?imageMogr2/auto-orient/strip|imageView2/2/w/960/format/webp"><h3 id="创建一个-monorepo"><a class="header-anchor" href="#创建一个-monorepo">#</a> 创建一个 monorepo</h3>',16),l={href:"https://segmentfault.com/a/1190000019350611",target:"_blank",rel:"noopener noreferrer"},c=(0,e.Uk)("lerna 教程详解"),r=(0,e.uE)('<h4 id="安装-lerna"><a class="header-anchor" href="#安装-lerna">#</a> 安装 lerna</h4><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>npm i lerna -g\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="初始化项目"><a class="header-anchor" href="#初始化项目">#</a> 初始化项目</h4><p>找一个空文件夹执行 lerna init 初始化项目。</p><h4 id="创建项目包"><a class="header-anchor" href="#创建项目包">#</a> 创建项目包</h4><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>lerna create moduleA\nlerna create moduleB\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="本地包相互引用"><a class="header-anchor" href="#本地包相互引用">#</a> 本地包相互引用</h4><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>lerna <span class="token function">link</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>假设 moduleA 依赖 moduleB，现在我们在 moduleA 包下增加个依赖。</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code>packages/moduleA/package.json\n\n<span class="token punctuation">{</span>\n  ...\n  <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span>  <span class="token punctuation">{</span>\n  <span class="token property">&quot;moduleB&quot;</span><span class="token operator">:</span>  <span class="token string">&quot;^1.0.0&quot;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  ...\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>在终端执行 lerna link 会在包中帮你安装 moduleB 依赖。</p><h4 id="添加公共依赖"><a class="header-anchor" href="#添加公共依赖">#</a> 添加公共依赖</h4><p>假设 moduleA 和 moduleB 都依赖 lodash</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>lerna <span class="token function">add</span> lodash\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="添加单独依赖"><a class="header-anchor" href="#添加单独依赖">#</a> 添加单独依赖</h4><p>假设 moduleA 自己依赖 jquery，moduleB 自己依赖 zepto</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>lerna <span class="token function">add</span> jquery --scope<span class="token operator">=</span>@na/moduleA\nlerna <span class="token function">add</span> zepto --scope<span class="token operator">=</span>@na/moduleB\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="卸载包"><a class="header-anchor" href="#卸载包">#</a> 卸载包</h4><p>给 moduleA 移除一个依赖 husky</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>lerna <span class="token builtin class-name">exec</span> --scope<span class="token operator">=</span>@na/moduleA <span class="token function">npm</span> uninstall husky\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h4 id="重新安装依赖"><a class="header-anchor" href="#重新安装依赖">#</a> 重新安装依赖</h4><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>lerna bootstrap\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这样会帮我们安装 package.json 里的 dependencies 依赖项</p><h4 id="抽离公共模块"><a class="header-anchor" href="#抽离公共模块">#</a> 抽离公共模块</h4><p>上面 moduleA 和 moduleB 都依赖了 lodash，且在各自 package 下的 node_modules 里都有副本，这其实很浪费空间，可以使用 --hoist</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>lerna bootstrap --hoist\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>这会将 packages 里重复的依赖提取到最外层的 node_modules 里，同时最外层的 package.json 也不会更新 dependency 信息，所以不建议将公用依赖写到最外层的 package.json 里，而是重复写到每个子 package.json 里，然后用 --hoist 提取出来</p><h4 id="更新公共依赖"><a class="header-anchor" href="#更新公共依赖">#</a> 更新公共依赖</h4><p>假设要升级 moduleA 和 moduleB 都依赖的 lodash 版本，不必依次到各子 package 下升级，可以借助 lerna-update-wizard 这个包来做</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token comment"># 根目录执行</span>\n<span class="token function">npm</span> <span class="token function">install</span> --save-dev lerna-update-wizard\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h4 id="发布"><a class="header-anchor" href="#发布">#</a> 发布</h4><ul><li>登录 npm</li><li>npm login</li><li>lerna changed 查看代码变化</li><li>lerna version 修改版本</li><li>lerna publish 发布</li></ul><h4 id="使用"><a class="header-anchor" href="#使用">#</a> 使用</h4><p>npm i @syyyds-cli/vue2wx --save</p><h4 id="使用脚手架"><a class="header-anchor" href="#使用脚手架">#</a> 使用脚手架：</h4><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token string">&quot;scripts&quot;</span><span class="token builtin class-name">:</span> <span class="token punctuation">{</span>\n    <span class="token string">&quot;dev&quot;</span><span class="token builtin class-name">:</span> <span class="token string">&quot;lsy-cli-repo-lerna&quot;</span>,\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="with-proxy-代理"><a class="header-anchor" href="#with-proxy-代理">#</a> with proxy 代理</h3><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 构造一个 with 来包裹需要执行的代码，返回 with 代码块的一个函数实例</span>\n<span class="token keyword">function</span> <span class="token function">withedYourCode</span><span class="token punctuation">(</span><span class="token parameter">code</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  code <span class="token operator">=</span> <span class="token string">&quot;with(globalObj) {&quot;</span> <span class="token operator">+</span> code <span class="token operator">+</span> <span class="token string">&quot;}&quot;</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Function</span><span class="token punctuation">(</span><span class="token string">&quot;globalObj&quot;</span><span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 可访问全局作用域的白名单列表</span>\n<span class="token keyword">const</span> accessWhiteList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;Math&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;Date&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;console&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 待执行程序</span>\n<span class="token keyword">const</span> code <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">\n    console.log(1111,Math.random());\n    func(foo)\n    location.href = &#39;xxx&#39;\n</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n\n<span class="token comment">// 执行上下文对象</span>\n<span class="token keyword">const</span> ctx <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">func</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">variable</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>variable<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  foo<span class="token operator">:</span> <span class="token string">&quot;foo&quot;</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 执行上下文对象的代理对象</span>\n<span class="token keyword">const</span> ctxProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token function-variable function">has</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> prop</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// has 可以拦截 with 代码块中任意属性的访问</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>accessWhiteList<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 在可访问的白名单内，可继续向上查找</span>\n      <span class="token keyword">return</span> target<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>target<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>prop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Invalid expression - </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>prop<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">! You can not do that!</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 普通的沙箱</span>\n<span class="token keyword">function</span> <span class="token function">normalSandbox</span><span class="token punctuation">(</span><span class="token parameter">code<span class="token punctuation">,</span> proxy</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">withedYourCode</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> proxy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 this 指向手动构造的全局代理对象</span>\n<span class="token punctuation">}</span>\n<span class="token function">normalSandbox</span><span class="token punctuation">(</span>code<span class="token punctuation">,</span> ctxProxy<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Uncaught Error: Invalid expression - location! You can not do that!</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br></div></div><h3 id="yarn-workspaces"><a class="header-anchor" href="#yarn-workspaces">#</a> yarn workspaces</h3><p>Yarn Workspaces 则是 Yarn 包管理器提供的一种特性，用于简化 Monorepo 中包的管理和依赖安装</p><h4 id="配置-yarn-workspaces"><a class="header-anchor" href="#配置-yarn-workspaces">#</a> 配置 Yarn Workspaces</h4><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token function">mkdir</span> my-monorepo\n<span class="token builtin class-name">cd</span> my-monorepo\n<span class="token function">yarn</span> init --scope<span class="token operator">=</span>@my-org <span class="token comment"># 初始化根目录的package.json，并设置scope</span>\n<span class="token comment"># 假设我们有两个包：ui-components和backend-api。</span>\n<span class="token function">mkdir</span> packages\n<span class="token builtin class-name">cd</span> packages\n<span class="token function">mkdir</span> ui-components backend-api\n<span class="token builtin class-name">cd</span> ui-components\n<span class="token function">yarn</span> init <span class="token comment"># 初始化ui-components的package.json</span>\n<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/backend-api\n<span class="token function">yarn</span> init <span class="token comment"># 同理初始化backend-api的package.json</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>编辑 package.json，添加 workspaces 字段</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;@my-org/my-monorepo&quot;</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;private&quot;</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;workspaces&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;packages/*&quot;</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>安装依赖</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code><span class="token builtin class-name">cd</span> packages/ui-components\n<span class="token function">yarn</span> <span class="token function">add</span> react react-dom <span class="token comment"># 为ui-components安装依赖</span>\n<span class="token function">yarn</span> <span class="token function">add</span> react -w ui-components <span class="token comment"># 或者</span>\n<span class="token builtin class-name">cd</span> <span class="token punctuation">..</span>/backend-api\n<span class="token function">yarn</span> <span class="token function">add</span> express <span class="token comment"># 为backend-api安装依赖</span>\n<span class="token function">yarn</span> <span class="token function">add</span> react -w backend-api <span class="token comment"># 或者</span>\n<span class="token function">yarn</span> <span class="token function">add</span> react --workspace-root <span class="token comment"># 在根目录安装</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="跨包共享依赖"><a class="header-anchor" href="#跨包共享依赖">#</a> 跨包共享依赖</h4><p>一些包是所有工作空间共用的，可以在根目录的 package.json 中安装这些依赖，并使用 nohoist 选项来防止这些依赖被提升到根目录，保持它们在每个工作空间内部</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;dependencies&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;lodash&quot;</span><span class="token operator">:</span> <span class="token string">&quot;^4.17.20&quot;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token property">&quot;workspaces&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;packages&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;packages/*&quot;</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;nohoist&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">&quot;**/lodash&quot;</span><span class="token punctuation">]</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h4 id="自动链接"><a class="header-anchor" href="#自动链接">#</a> 自动链接</h4><p>Yarn Workspaces 会自动在本地开发环境中创建软链接，使得在开发一个包时，对它的改动可以立即反映到依赖它的其他包中，无需重新发布或安装。<br> 这意味着当你修改了 ui-components，在 backend-api 中如果直接引用了 ui-components，那么改动会即时生效，无需额外操作</p><h4 id="脚本跨包共享"><a class="header-anchor" href="#脚本跨包共享">#</a> 脚本跨包共享</h4><p>在根目录的 package.json 中定义这些脚本，并利用 yarn workspace 命令在各个包中执行它们</p><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token punctuation">{</span>\n  <span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>\n    <span class="token property">&quot;lint&quot;</span><span class="token operator">:</span> <span class="token string">&quot;eslint &#39;packages/*/src&#39;&quot;</span><span class="token punctuation">,</span>\n    <span class="token property">&quot;test&quot;</span><span class="token operator">:</span> <span class="token string">&quot;yarn workspace ui-components test &amp;&amp; yarn workspace backend-api test&quot;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div>',54),u={render:function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.j4)(e.HY,null,[(0,e.Wm)("p",null,[(0,e.Wm)("a",p,[o,(0,e.Wm)(a)])]),t,(0,e.Wm)("p",null,[(0,e.Wm)("a",l,[c,(0,e.Wm)(a)])]),r],64)}}}}]);