(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[4994],{2638:(l,e,i)=>{"use strict";i.r(e),i.d(e,{data:()=>r});const r={key:"v-3d36d764",path:"/pages/backend/Java/",title:"",lang:"zh-CN",frontmatter:{home:!1,sidebar:!1},excerpt:"",headers:[{level:3,title:"静态变量特性",slug:"静态变量特性",children:[]},{level:3,title:"继承规则",slug:"继承规则",children:[]},{level:3,title:"抽象方法",slug:"抽象方法",children:[]},{level:3,title:"volatile 修饰符",slug:"volatile-修饰符",children:[]},{level:3,title:"StringBuffer、StringBuilder",slug:"stringbuffer、stringbuilder",children:[]},{level:3,title:"方法重载、方法重写",slug:"方法重载、方法重写",children:[]}],filePathRelative:"pages/backend/Java/README.md",git:{updatedTime:1741701936e3,contributors:[{name:"COOKIES-LGL",email:"1344714332@qq.com",commits:4}]}}},9435:(l,e,i)=>{"use strict";i.r(e),i.d(e,{default:()=>a});const r=(0,i(6252).uE)('<ul><li><a href="./Maven">Maven</a> <span style="color:#bbb;float:right;">2024-06-30</span></li><li>starter 可以快速整合 shiro-redis，配置简单</li><li>lombok：简化代码的工具</li></ul><h3 id="静态变量特性"><a class="header-anchor" href="#静态变量特性">#</a> 静态变量特性</h3><p>Java 中的静态变量是属于类的，而不是对象的实例。因此，当多个线程同时访问一个包含静态变量的类时，需要考虑其线程安全性。</p><p>静态变量在内存中只有一份拷贝，被所有实例共享。因此，如果一个线程修改了静态变量的值，那么其他线程在访问该静态变量时也会看到修改后的值。这可能会导致并发访问的问题，因为多个线程可能同时修改静态变量，导致不确定的结果或数据一致性问题。</p><p>为了确保静态变量的线程安全性，需要采取适当的同步措施，如同步机制、原子类或 volatile 关键字，以便在多线程环境中正确地读取和修改静态变量的值</p><h3 id="继承规则"><a class="header-anchor" href="#继承规则">#</a> 继承规则</h3><ul><li><p>父类中声明为 public 的方法在子类中也必须为 public。</p></li><li><p>父类中声明为 protected 的方法在子类中要么声明为 protected，要么声明为 public，不能声明为 private。</p></li><li><p>父类中声明为 private 的方法，不能够被子类继承。</p></li><li><p>父类中的 final 方法可以被子类继承，但是不能被子类重写</p></li><li><p>final 类不能被继承，没有类能够继承 final 类的任何特性</p></li><li><p>extends 是单一继承、implements 是可以同时继承多个接口（接口跟接口之间采用逗号分隔）</p></li></ul><h3 id="抽象方法"><a class="header-anchor" href="#抽象方法">#</a> 抽象方法</h3><ul><li><p>抽象类可以包含抽象方法和非抽象方法。</p></li><li><p>抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供。</p></li><li><p>抽象方法不能被声明成 final 和 static。</p></li><li><p>任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类。</p></li><li><p>如果一个类包含若干个抽象方法，那么该类必须声明为抽象类。抽象类可以不包含抽象方法</p></li></ul><h3 id="volatile-修饰符"><a class="header-anchor" href="#volatile-修饰符">#</a> volatile 修饰符</h3><p>volatile 修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量的值。而且，当成员变量发生变化时，会强制线程将变化值回写到共享内存。<br> 这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。一个 volatile 对象引用可能是 null。</p><h3 id="stringbuffer、stringbuilder"><a class="header-anchor" href="#stringbuffer、stringbuilder">#</a> StringBuffer、StringBuilder</h3><p>和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象在使用 StringBuffer 类时， 所以如果需要对字符串进行修改推荐使用 StringBuffer。由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder。</p><h3 id="方法重载、方法重写"><a class="header-anchor" href="#方法重载、方法重写">#</a> 方法重载、方法重写</h3><ul><li>(1)方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载(Overloading)。</li><li>(2)方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写(Overriding)。</li><li>多态性的核心：一个父类类型的引用可以指向其子类的对象，并且在运行时根据对象的实际类型调用相应的方法</li></ul><h4 id="jdk-国内镜像"><a class="header-anchor" href="#jdk-国内镜像">#</a> jdk 国内镜像</h4><p>https://repo.huaweicloud.com/java/jdk/8u172-b11/</p>',17),a={render:function(l,e){return r}}}}]);