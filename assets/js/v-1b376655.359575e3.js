(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[7096],{8854:(n,s,a)=>{"use strict";a.r(s),a.d(s,{data:()=>e});const e={key:"v-1b376655",path:"/pages/blog-daily/webpack-four-to-five/",title:"",lang:"zh-CN",frontmatter:{sidebar:"auto"},excerpt:"",headers:[{level:2,title:"使用要点",slug:"使用要点",children:[{level:3,title:"常用 loader",slug:"常用-loader",children:[]},{level:3,title:"webpack 新版配置 不再支持在 rules 里同时配置 use 和 options",slug:"webpack-新版配置-不再支持在-rules-里同时配置-use-和-options",children:[]}]}],filePathRelative:"pages/blog-daily/webpack-four-to-five/README.md",git:{updatedTime:1733294272e3,contributors:[{name:"COOKIES-LGL",email:"1344714332@qq.com",commits:2},{name:"guilin.li",email:"1344714332@qq.com",commits:1}]}}},5685:(n,s,a)=>{"use strict";a.r(s),a.d(s,{default:()=>p});const e=(0,a(6252).uE)('<h2 id="使用要点"><a class="header-anchor" href="#使用要点">#</a> 使用要点</h2><p>webpack 5 不再引入 Node.js 变量的 polyfill，在前端代码中应避免使用。</p><p>你可能会收到很多弃用警告，插件需要时间来赶上内核的变化。请将这些弃用上报给插件。这些弃用只是警告，构建仍然可以正常工作。 你使用带有 --no-deprecation 选项的 node 运行 webpack，可以隐藏废弃告警，例如</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>node --no-deprecation node_modules/webpack/bin/webpack.js\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>一般来说，webpack 5 的性能应该会有所提高，但也存在少数情况性能会变差。 而在这里，你可以做一些事清来改善这种情况：</p><p>在 webpack4 中 url-loader 使用 loaders 的配置已经被废弃掉，而在 webpack5 中 url-loader 在使用 options 配置的时候必须要使用 use 数组，相应的 loader 也要使用对象的形式来书写。</p><p>webpack5 中废弃掉了 compiler.plugin()的方式调用。</p><h3 id="常用-loader"><a class="header-anchor" href="#常用-loader">#</a> 常用 loader</h3><details>   <summary>cache-loader</summary><div><pre>  // 用法\n  module.exports = {\n    module: {\n      rules: [\n        {\n          test: /\\.ext$/,\n          use: [\n            &#39;cache-loader&#39;,\n            ...loaders\n          ],\n          include: path.resolve(&#39;src&#39;)\n        }\n      ]\n    }\n  }\n  注意⚠️ 保存和读取这些缓存文件会有一些时间开销，所以请只对性能开销较大的 loader 使用此 loader。\n  </pre></div></details><details>   <summary>imports-loader</summary><div><pre>  // 用法\n  module.exports = {\n    module: {\n      rules: [\n        {\n         test: require.resolve(&#39;./src/index.js&#39;),\n         use: &#39;imports-loader?wrapper=window&#39;,\n        }\n      ]\n    }\n  }\n  当项目运行在浏览器的时候this指向window,\n  当模块运行在 CommonJS 上下文中，这将会变成一个问题，也就是说此时的 this 指向的是 module.exports。\n  在这种情况下，你可以通过使用 imports-loader 覆盖 this 指向：\n  </pre></div></details><details>   <summary>ProvidePlugin</summary><div><pre>  // 用法\n  module.exports = {\n    entry: &#39;./src/index.js&#39;,\n    output: {\n      filename: &#39;main.js&#39;,\n      path: path.resolve(__dirname, &#39;dist&#39;),\n    },\n    plugins: [\n      new webpack.ProvidePlugin({\n        _: &#39;lodash&#39;,\n      }),\n    ],\n  };\n  这个时候lodash就不需要单独导入了,它已经被预置了\n  plugins: [\n  new webpack.ProvidePlugin({\n    join: [&#39;lodash&#39;, &#39;join&#39;],\n  }),\n  // 按需单独预设置,可以配合treeSharking使用\n  </pre></div></details><p>现在，如果执行 webpack，你会发现创建了一个体积相当大的文件。如果你查看这个文件，会看到 lodash 也被打包到代码中。在这种场景中，我们更倾向于把 lodash 当作 peerDependency。也就是说，consumer(使用者) 应该已经安装过 lodash 。因此，你就可以放弃控制此外部 library ，而是将控制权让给使用 library 的 consumer。</p><p>这可以使用 externals 配置来完成： externals: { lodash: { commonjs: &#39;lodash&#39;, commonjs2: &#39;lodash&#39;, amd: &#39;lodash&#39;, root: &#39;_&#39;, }, }, 对于想要实现从一个依赖中调用多个文件的那些 library： externals: [ &#39;library/one&#39;, &#39;library/two&#39;, // 匹配以 &quot;library/&quot; 开始的所有依赖 /^library/.+$/, ],</p><p>我们可以看到这三个文件的 hash 都变化了。这是因为每个 module.id 会默认地基于解析顺序(resolve order)进行增量。也就是说，当解析顺序发生变化，ID 也会随之改变。简要概括：</p><p>main bundle 会随着自身的新增内容的修改，而发生变化。 vendor bundle 会随着自身的 module.id 的变化，而发生变化。 manifest runtime 会因为现在包含一个新模块的引用，而发生变化。 第一个和最后一个都是符合预期的行为，vendor hash 发生变化是我们要修复的。我们将 optimization.moduleIds 设置为 &#39;deterministic&#39;：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>optimization: <span class="token punctuation">{</span>\n  moduleIds: <span class="token string">&#39;deterministic&#39;</span>,\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>正如我们在 代码分离 中所学到的，SplitChunksPlugin 可以用于将模块分离到单独的 bundle 中。webpack 还提供了一个优化功能，可使用 optimization.runtimeChunk 选项将 runtime 代码拆分为一个单独的 chunk。将其设置为 single 来为所有 chunk 创建一个 runtime bundle：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>optimization: <span class="token punctuation">{</span>\n  runtimeChunk: <span class="token string">&#39;single&#39;</span>,\n<span class="token punctuation">}</span>,\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>我们知道 JavaScript 属于解释型语言，JavaScript 的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样： 解释阶段：</p><ul><li>词法分析</li><li>语法分析</li><li>作用域规则确定</li></ul><p>执行阶段：</p><ul><li>创建执行上下文</li><li>执行函数代码</li><li>垃圾回收</li></ul><p>JavaScript 解释阶段便会确定作用域规则，因此作用域在函数定义时就已经确定了，而不是在函数调用时确定，但是执行上下文是函数执行之前创建的。执行上下文最明显的就是 this 的指向是执行时确定的。而作用域访问的变量是编写代码的结构确定的。 作用域和执行上下文之间最大的区别是： 执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变。 一个作用域下可能包含若干个上下文环境。有可能从来没有过上下文环境（函数从来就没有被调用过）；有可能有过，现在函数被调用完毕后，上下文环境被销毁了；有可能同时存在一个或多个（闭包）。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。</p><h3 id="webpack-新版配置-不再支持在-rules-里同时配置-use-和-options"><a class="header-anchor" href="#webpack-新版配置-不再支持在-rules-里同时配置-use-和-options">#</a> webpack 新版配置 不再支持在 rules 里同时配置 use 和 options</h3><div class="language-json ext-json line-numbers-mode"><pre class="language-json"><code><span class="token comment">// 旧</span>\n<span class="token punctuation">{</span>\n    module<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 指定要加载的规则</span>\n        rules<span class="token operator">:</span> <span class="token punctuation">[</span>\n            <span class="token punctuation">{</span>\n                test<span class="token operator">:</span> /\\.ts$/<span class="token punctuation">,</span> <span class="token comment">// test指定的是规则生效的文件</span>\n                use<span class="token operator">:</span> &#39;ts-loader&#39;<span class="token punctuation">,</span>\n                options<span class="token operator">:</span> <span class="token punctuation">{</span>\n                    compilerOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n                        noEmit<span class="token operator">:</span> <span class="token boolean">false</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span><span class="token punctuation">,</span>\n                exclude<span class="token operator">:</span> /node-modules/\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 新</span>\n<span class="token punctuation">{</span>\n    module<span class="token operator">:</span> <span class="token punctuation">{</span>\n        <span class="token comment">// 指定要加载的规则</span>\n        rules<span class="token operator">:</span> <span class="token punctuation">[</span>\n            <span class="token punctuation">{</span>\n                test<span class="token operator">:</span> /\\.ts$/<span class="token punctuation">,</span> <span class="token comment">// test指定的是规则生效的文件</span>\n                use<span class="token operator">:</span> <span class="token punctuation">{</span>\n                    loader<span class="token operator">:</span> &#39;ts-loader&#39;<span class="token punctuation">,</span>\n                    options<span class="token operator">:</span> <span class="token punctuation">{</span>\n                        compilerOptions<span class="token operator">:</span> <span class="token punctuation">{</span>\n                            noEmit<span class="token operator">:</span> <span class="token boolean">false</span>\n                        <span class="token punctuation">}</span>\n                    <span class="token punctuation">}</span>\n                <span class="token punctuation">}</span><span class="token punctuation">,</span>\n                exclude<span class="token operator">:</span> /node-modules/\n            <span class="token punctuation">}</span>\n        <span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div>',25),p={render:function(n,s){return e}}}}]);