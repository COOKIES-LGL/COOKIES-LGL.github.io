(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[4127],{4311:(e,l,a)=>{"use strict";a.r(l),a.d(l,{data:()=>i});const i={key:"v-16715b94",path:"/pages/react/ssr/performance-optimization/",title:"性能优化",lang:"zh-CN",frontmatter:{title:"性能优化"},excerpt:"",headers:[{level:2,title:"Stream 渲染",slug:"stream-渲染",children:[]},{level:2,title:"更快的接口调用速度",slug:"更快的接口调用速度",children:[]},{level:2,title:"减少首屏抖动",slug:"减少首屏抖动",children:[]},{level:2,title:"控制首屏大小",slug:"控制首屏大小",children:[{level:3,title:"如何控制首屏内容？",slug:"如何控制首屏内容",children:[]}]},{level:2,title:"图片控制",slug:"图片控制",children:[{level:3,title:"选择正确的图片格式",slug:"选择正确的图片格式",children:[]},{level:3,title:"文件大小控制",slug:"文件大小控制",children:[]},{level:3,title:"渐进加载",slug:"渐进加载",children:[]}]},{level:2,title:"JS 体积优化",slug:"js-体积优化",children:[{level:3,title:"检查重复依赖",slug:"检查重复依赖",children:[]},{level:3,title:"lodash 按需引用",slug:"lodash-按需引用",children:[]},{level:3,title:"推荐使用 dayjs 替换 moment",slug:"推荐使用-dayjs-替换-moment",children:[]}]}],filePathRelative:"pages/react/ssr/performance-optimization/README.md",git:{updatedTime:172681525e4,contributors:[{name:"COOKIES-LGL",email:"1344714332@qq.com",commits:2}]}}},9964:(e,l,a)=>{"use strict";a.r(l),a.d(l,{default:()=>h});const i=(0,a(6252).uE)('<p>SSR 带来的性能提升主要在以下几点：</p><ol><li>SSR 直出 HTML 可缩短首屏时间减少用户等待</li><li>Node 内网接口调用相比用户公网环境调用 RT 更短</li></ol><p>主要也是围绕着 SSR 上述流程中的各个节点结合浏览器/ Node 特性进行优化：</p><h2 id="stream-渲染"><a class="header-anchor" href="#stream-渲染">#</a> Stream 渲染</h2><h2 id="更快的接口调用速度"><a class="header-anchor" href="#更快的接口调用速度">#</a> 更快的接口调用速度</h2><p>通过使用 <code>Promise.all</code> 可以并发处理发起两个请求，因此， fetch 的响应时间为 <code>Max(data1, data2)</code>，可以极大的提升请求耗时。</p><h2 id="减少首屏抖动"><a class="header-anchor" href="#减少首屏抖动">#</a> 减少首屏抖动</h2><p>HTML 进入浏览器渲染时，由于页面抖动，会导致浏览器频繁触发重排和重绘，既影响用户体验，又影响页面性能，因此，我们需要确保 SSR 渲染结果在浏览器渲染时尽可能减少抖动，因此需要考虑如下点：</p><ul><li>img、video 等媒体元素都显式的声明宽高（图片使用 BImage 组件）</li><li>无法在 node 环境渲染的组件提供占位空节点，使用 LazyLoad 组件 在客户端进行 rerender</li></ul><h2 id="控制首屏大小"><a class="header-anchor" href="#控制首屏大小">#</a> 控制首屏大小</h2><p>为了最快响应用户请求，我们希望服务端能尽可能快的交付页面渲染结果。因此，在 SSR 中，我们更关心首屏重要内容优先渲染，这样有几个好处：</p><ul><li>更多的内容可能需要调用更多的接口，可能造成接口请求瓶颈</li><li>更多的内容渲染需要执行更多的 jsx 代码，耗时更高</li><li>更多的内容会造成 Node 占用更多内存</li><li>更多的内容浏览器需要加载更多的数据，网络耗时更久</li><li>更多的内容浏览器解析 HTML 和绘制的时间也成倍增加</li></ul><p>控制首屏大小的边界在哪里呢？可能涉及如下场景：</p><ul><li>列表页只加载第一页数据</li><li>Tab 只加载第一个 Tab（或选中的 Tab）数据</li><li>RT 慢的非关键请求放到 CSR 阶段请求渲染</li></ul><h3 id="如何控制首屏内容"><a class="header-anchor" href="#如何控制首屏内容">#</a> 如何控制首屏内容？</h3><p>上文提到需要将非首屏内容延迟渲染，具体实际代码中如何延迟呢？有以下几种典型的场景：</p><h4 id="纯列表页"><a class="header-anchor" href="#纯列表页">#</a> 纯列表页</h4><p>这种场景比较简单，只需根据页面 UI 按照一定经验值控制首页 pageSize 即可，例如上面的商品列表，可见大部分手机首屏可展示的商品数量不超过 5 个楼层（即 10 个商品），我们把首屏请求的 pageSize 设为 10 即可，后面的页面可能根据需求，pageSize 为 20 或者更少。</p><h4 id="tab-页"><a class="header-anchor" href="#tab-页">#</a> Tab 页</h4><p>Tab 页场景也比较典型，只有被激活的 tab 区域才应该在服务端直出，而其他 tab 内容完全可以等到 CSR 阶段（或点击时）再触发渲染。</p><h4 id="多个楼层"><a class="header-anchor" href="#多个楼层">#</a> 多个楼层</h4><p>这个页面包含 banner、精选直播课、为你推荐、精品系列课等多个楼层，但是在手机有限的屏幕高度限制下，只有红框内属于首屏内容，因此完全可以将【精品系列课】楼层等到 CSR 环境下再进行渲染，减小首屏大小。如何控制非首屏内容渲染呢，可以使用 LazyLoad 组件</p><h2 id="图片控制"><a class="header-anchor" href="#图片控制">#</a> 图片控制</h2><p>图片的加载在整个页面性能中占据重要的比重，值得单独进行优化。</p><h3 id="选择正确的图片格式"><a class="header-anchor" href="#选择正确的图片格式">#</a> 选择正确的图片格式</h3><p>不同图片格式的适用场景、文件大小都有所差异，选择适合的图片格式能更好的兼顾性能与显示效果。具体的图片优劣势网上已经有很多文章谈到，这里不再赘述，一般来讲我们可以按照以下场景选择相应的图片格式：</p><ul><li>【jpg】普通商品图、banner 等包含文字、色彩丰富</li><li>【png】包含透明通道</li><li>【svg】矢量图、icon</li><li>【gif】色彩简单的动画</li><li>【webp】支持 webp 格式的浏览器统一都用 webp</li></ul><h3 id="文件大小控制"><a class="header-anchor" href="#文件大小控制">#</a> 文件大小控制</h3><p>更大的文件尺寸需要消耗更多的加载时间，对文件大小的控制我们也可以遵循以下基本规律。</p><h4 id="图片尺寸"><a class="header-anchor" href="#图片尺寸">#</a> 图片尺寸</h4><p>下图显示了不合理的图片尺寸对文件大小的影响，在使用图片时，我们需要根据显示尺寸合理的剪裁图片，假设需要在一个 100*100 的 div 上展示一个背景图，那么我们的图片自然尺寸应该和 div 尺寸保持一致，并根据设备 DPI 选择 2 倍或 3 倍图。</p><h4 id="图片质量"><a class="header-anchor" href="#图片质量">#</a> 图片质量</h4><p>图片质量对文件大小的影响也是显而易见的，但同时，图片质量也会对显示效果造成影响，一般来讲我们可以按照以下场景选择相应的图片格式：</p><p><strong>JPG/WEBP</strong></p><ul><li>【80】包含渐变等带有过渡效果的图片</li><li>【70】包含文字的图片</li><li>【50】普通图片</li></ul><p>对于 jpg 而已，图片质量对显示效果的影响呈现边际递减效应，一般图片质量超过 90 就很难肉眼看到差异了，因此没必要为了追求极端的质量而导致体积增加。</p><p><strong>PNG</strong></p><p>使用 CDN 提供的 PNG 无损压缩。</p><h4 id="去除元信息"><a class="header-anchor" href="#去除元信息">#</a> 去除元信息</h4><p>很多图片在导出时都包含大量的元信息，包含 exif 信息等，这些元信息也显著影响着图片的尺寸，因为在使用前，我们需要将图片元信息清除。</p><h3 id="渐进加载"><a class="header-anchor" href="#渐进加载">#</a> 渐进加载</h3><p>为了更快的首屏展示，我们希望图片能够渐进加载，让用户先看到内容、再看到更清晰的内容。因此，我们需要考虑在服务端渲染直出的图片大小在 kb 级别（参考上文的文件大小控制，以极小的图片尺寸、极低的图片质量将图片控制在 kb 大小），等首屏渲染完成后，再将小图替换为高清大图。</p><h4 id="合理的图片请求数"><a class="header-anchor" href="#合理的图片请求数">#</a> 合理的图片请求数</h4><p>虽然目前浏览器已经有充足的并发请求数量，但我们仍然需要考虑大量请求并发造成的网络资源竞争问题，因此需要将首屏的图片请求数（甚至是资源请求数）控制在合理的范围，我们需要考虑以下场景：</p><ul><li>非可视区域内的图片不请求（不在首屏的图片、轮播第二屏的图片、横向滚动不在可视区的图片等）</li><li>合理控制轮播图的速度</li><li>合理使用预加载</li></ul><h4 id="自适应图片"><a class="header-anchor" href="#自适应图片">#</a> 自适应图片</h4><p>有两种场景下应该对图片的尺寸、格式进行自适应：</p><ul><li>根据用户设备 DPI（每英寸像素点数）动态调整图片倍率</li><li>根据用户网络动态调整图片大小（弱网使用更小的图片尺寸和倍率、更高的压缩比）</li></ul><h4 id="显示效果调优"><a class="header-anchor" href="#显示效果调优">#</a> 显示效果调优</h4><p>当 JPG 图片经过上面提到的压缩后，会对显示效果造成一定的影响，为了在压缩后提供更好的现实效果，我们可以通过以下参数进行一定的调优：</p><ul><li>在高分辨率屏幕上使用多倍图</li><li>通过 sharpen 参数增加图片锐度（对于包含文字等有大量清晰边界线的图片，可适度提高图片锐度参数）</li><li>通过以上两种手段在一定程度上可以让用户显示效果更好。</li></ul><h2 id="js-体积优化"><a class="header-anchor" href="#js-体积优化">#</a> JS 体积优化</h2><h3 id="检查重复依赖"><a class="header-anchor" href="#检查重复依赖">#</a> 检查重复依赖</h3><p>重复依赖不仅会导致 JS 体积增大，部分模块存在多个版本甚至会引发线上故障，因此请自查是否有重复依赖问题，可在项目根目录运行模块分析命令进行检查，如果有将重复的依赖 resolutions 到最高的版本 (跨大版本请严格测试)：</p><div class="language-bash ext-sh line-numbers-mode"><pre class="language-bash"><code>npx pin webpack --analyze\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="lodash-按需引用"><a class="header-anchor" href="#lodash-按需引用">#</a> lodash 按需引用</h3><h3 id="推荐使用-dayjs-替换-moment"><a class="header-anchor" href="#推荐使用-dayjs-替换-moment">#</a> 推荐使用 dayjs 替换 moment</h3>',57),h={render:function(e,l){return i}}}}]);