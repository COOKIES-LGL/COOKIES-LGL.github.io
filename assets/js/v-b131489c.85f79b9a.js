(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[6843],{5706:(e,l,i)=>{"use strict";i.r(l),i.d(l,{data:()=>a});const a={key:"v-b131489c",path:"/pages/fe-interview/answer-question/",title:"",lang:"zh-CN",frontmatter:{home:!1,sidebar:!1},excerpt:"",headers:[{level:3,title:"为啥使用 img gif 做埋点",slug:"为啥使用-img-gif-做埋点",children:[]},{level:3,title:"为什么 Vue 不需要 Fiber",slug:"为什么-vue-不需要-fiber",children:[]},{level:3,title:"跨域知识点",slug:"跨域知识点",children:[]},{level:3,title:"为啥 React 在 componentDidCatch 上报错误",slug:"为啥-react-在-componentdidcatch-上报错误",children:[]},{level:3,title:"common.js 和 es6 中模块引入的区别",slug:"common-js-和-es6-中模块引入的区别",children:[]}],filePathRelative:"pages/fe-interview/answer-question/README.md",git:{updatedTime:174334645e4,contributors:[{name:"COOKIES-LGL",email:"1344714332@qq.com",commits:7}]}}},6169:(e,l,i)=>{"use strict";i.r(l),i.d(l,{default:()=>c});var a=i(6252);const s=(0,a.Wm)("h3",{id:"为啥使用-img-gif-做埋点"},[(0,a.Wm)("a",{class:"header-anchor",href:"#为啥使用-img-gif-做埋点"},"#"),(0,a.Uk)(" 为啥使用 img gif 做埋点")],-1),n=(0,a.Wm)("ul",null,[(0,a.Wm)("li",null,"img 兼容性好"),(0,a.Wm)("li",null,"无需挂载到页面上，反复操作 dom"),(0,a.Wm)("li",null,"img 的加载不会阻塞 html 的解析，但 img 加载后并不渲染，它需要等待 Render Tree 生成完后才和 Render Tree 一起渲染出来"),(0,a.Wm)("li",null,"注：通常埋点上报会使用 gif 图，合法的 GIF 只需要 43 个字节")],-1),r=(0,a.Wm)("h3",{id:"为什么-vue-不需要-fiber"},[(0,a.Wm)("a",{class:"header-anchor",href:"#为什么-vue-不需要-fiber"},"#"),(0,a.Uk)(" 为什么 Vue 不需要 Fiber")],-1),t=(0,a.Uk)("响应式系统：Vue 的依赖追踪机制已实现高效更新，无需通过 Fiber 的复杂调度解决性能问题。 同步更新足够高效：在大多数场景下，Vue 的同步批量更新不会导致主线程卡顿（除非组件树异常复杂）。 设计取舍：Vue 选择简化开发者体验，通过编译时优化（如静态提升）和运行时优化（如 Proxy 响应式）规避性能瓶颈。 "),o=(0,a.uE)('<h3 id="跨域知识点"><a class="header-anchor" href="#跨域知识点">#</a> 跨域知识点</h3><p>跨域并不是请求发不出去，请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了 OPTIONS 请求次数过多也会损耗性能，所以要尽量减少 OPTIONS 请求，可以让服务器在请求返回头部添加</p><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code>Access<span class="token operator">-</span>Control<span class="token operator">-</span>Max<span class="token operator">-</span>Age<span class="token operator">:</span> Number <span class="token comment">// 数字 单位是秒</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><h3 id="为啥-react-在-componentdidcatch-上报错误"><a class="header-anchor" href="#为啥-react-在-componentdidcatch-上报错误">#</a> 为啥 React 在 componentDidCatch 上报错误</h3><ul><li>getDerivedStateFromError 在渲染阶段被调用，返回组建 state，用于渲染备用 UI</li><li>componentDidCatch 在提交阶段执行，进行错误上报。</li><li>React 通过 getDerivedStateFromError 和 componentDidCatch 的分离设计，实现了错误处理中状态更新与副作用执行的解耦，既保证了渲染阶段的稳定性。</li></ul><h3 id="common-js-和-es6-中模块引入的区别"><a class="header-anchor" href="#common-js-和-es6-中模块引入的区别">#</a> common.js 和 es6 中模块引入的区别</h3><ul><li>1、CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。</li><li>2、CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。</li><li>3、CommonJs 是单个值导出，ES6 Module 可以导出多个</li><li>4、CommonJs 是动态语法可以写在判断里，ES6 Module 静态语法只能写在顶层</li><li>5、CommonJs 的 this 是当前模块，ES6 Module 的 this 是 undefined</li></ul>',7),c={render:function(e,l){return(0,a.wg)(),(0,a.j4)(a.HY,null,[s,n,r,(0,a.Wm)("p",null,[t,(0,a.Wm)("img",{src:e.$withBase("./images/daily-blog/vue-diff-react1.png"),class:"show-in-center"},null,8,["src"])]),o],64)}}}}]);