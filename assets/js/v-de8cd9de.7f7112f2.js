(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[7424],{522:(e,l,a)=>{"use strict";a.r(l),a.d(l,{data:()=>s});const s={key:"v-de8cd9de",path:"/pages/react/ssr/",title:"",lang:"zh-CN",frontmatter:{home:!1},excerpt:"",headers:[{level:2,title:"SSR 相关",slug:"ssr-相关",children:[{level:3,title:"技术文档列表",slug:"技术文档列表",children:[]},{level:3,title:"服务端组件和 SSR 有哪些不同",slug:"服务端组件和-ssr-有哪些不同",children:[]},{level:3,title:"next.js 水合失败的原因",slug:"next-js-水合失败的原因",children:[]}]}],filePathRelative:"pages/react/ssr/README.md",git:{updatedTime:172681525e4,contributors:[{name:"COOKIES-LGL",email:"1344714332@qq.com",commits:2}]}}},2173:(e,l,a)=>{"use strict";a.r(l),a.d(l,{default:()=>t});const s=(0,a(6252).uE)('<h2 id="ssr-相关"><a class="header-anchor" href="#ssr-相关">#</a> SSR 相关</h2><h3 id="技术文档列表"><a class="header-anchor" href="#技术文档列表">#</a> 技术文档列表</h3><ul><li><a href="./fallback-operation">架构降级</a> <span style="color:#bbb;float:right;">2024-05-10</span></li><li><a href="./performance-optimization">性能优化</a> <span style="color:#bbb;float:right;">2024-02-10</span></li><li><a href="./stream">流式渲染</a> <span style="color:#bbb;float:right;">2024-02-10</span></li></ul><h3 id="服务端组件和-ssr-有哪些不同"><a class="header-anchor" href="#服务端组件和-ssr-有哪些不同">#</a> 服务端组件和 SSR 有哪些不同</h3><div class="custom-container tip"><p class="custom-container-title">TIP</p><p>在使用 SSR 时，你需要先在服务端完成 HTML 的渲染，然后再将该 HTML 发送到客户端。然后此过程只会发生在页面的初次访问时（也就是初始化加载的时候）。至此之后，你的 React 应用在数据更新展示等行为表现上和常规的 React 应用没有任何区别。在展示更新之后的数据时，都是要么从客户端发送一个网络请求，要么页面整体刷新，但不管采用哪种方式，都会导致组件的二次渲染和状态丢失，从而影响性能和客户体验。 相对而言，在使用服务端组件时，你的组件在服务端完成渲染，然后通过自定义的协议发送到客户端（如下图）。React 拿到数据时，将新的 UI 整体的合并到客户端 UI 树里面，此过程不会对客户端其他状态产生影响。此过程可以无限次数的执行。React 通过整体 UI 模块更新的方式，达到保持客户端状态的目的，极大的增强了用户体验。</p></div><h3 id="next-js-水合失败的原因"><a class="header-anchor" href="#next-js-水合失败的原因">#</a> next.js 水合失败的原因</h3><ul><li>HTML 元素错误嵌套导致</li><li>变量在服务端和客户端的取值不一致渲染了不同的 html。</li><li>组件涉及倒计时和时间戳相关的要格外留意，可以统一使用服务端时间或者服务端不渲染。</li><li>时区不匹配，服务器上创建一个日期与客户端的不匹配。</li><li>还有随机 key，有些弹窗会配置随机 key 由 uuid 生成</li></ul>',7),t={render:function(e,l){return s}}}}]);