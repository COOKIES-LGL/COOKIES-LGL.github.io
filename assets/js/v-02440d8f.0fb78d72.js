(self.webpackChunkvuepress_blog=self.webpackChunkvuepress_blog||[]).push([[6848],{9840:(e,r,o)=>{"use strict";o.r(r),o.d(r,{data:()=>l});const l={key:"v-02440d8f",path:"/pages/computer-network/",title:"",lang:"zh-CN",frontmatter:{home:!1,sidebar:!1},excerpt:"",headers:[{level:2,title:"计算机网络日常笔记",slug:"计算机网络日常笔记",children:[{level:3,title:"技术文档列表",slug:"技术文档列表",children:[]},{level:3,title:"MarkDown 使用指南",slug:"markdown-使用指南",children:[]}]}],filePathRelative:"pages/computer-network/README.md",git:{updatedTime:1740469195e3,contributors:[{name:"COOKIES-LGL",email:"1344714332@qq.com",commits:5},{name:"guilin.li",email:"1344714332@qq.com",commits:1}]}}},1322:(e,r,o)=>{"use strict";o.r(r),o.d(r,{default:()=>b});var l=o(6252);const a=(0,l.Wm)("h2",{id:"计算机网络日常笔记"},[(0,l.Wm)("a",{class:"header-anchor",href:"#计算机网络日常笔记"},"#"),(0,l.Uk)(" 计算机网络日常笔记")],-1),n=(0,l.Wm)("h3",{id:"技术文档列表"},[(0,l.Wm)("a",{class:"header-anchor",href:"#技术文档列表"},"#"),(0,l.Uk)(" 技术文档列表")],-1),t={href:"https://blog.poetries.top/browser-working-principle/guide/part6/lesson36.html#%E5%9C%A8-http-%E5%8D%8F%E8%AE%AE%E6%A0%88%E4%B8%AD%E5%BC%95%E5%85%A5%E5%AE%89%E5%85%A8%E5%B1%82",target:"_blank",rel:"noopener noreferrer"},c=(0,l.Uk)("HTTPS"),s=(0,l.Uk)(),h=(0,l.Wm)("span",{style:{color:"#bbb",float:"right"}},"2021-06-10",-1),p={href:"https://blog.poetries.top/browser-working-principle/guide/part6/lesson30.html",target:"_blank",rel:"noopener noreferrer"},i=(0,l.Uk)("HTTP2.0 协议"),m=(0,l.Uk)(),u=(0,l.Wm)("span",{style:{color:"#bbb",float:"right"}},"2022-06-10",-1),d={href:"https://www.cnblogs.com/slowlydance2me/p/16928574.html",target:"_blank",rel:"noopener noreferrer"},g=(0,l.Uk)("计算机底层网络"),k=(0,l.uE)('<h4 id="日常知识点"><a class="header-anchor" href="#日常知识点">#</a> 日常知识点</h4><h4 id="request-cache-control"><a class="header-anchor" href="#request-cache-control">#</a> request cache-control</h4><p>request cache-control 是由客户端（通常是浏览器）在发送 HTTP 请求时设置的，用于指示服务器或中间缓存（如 CDN）如何处理该请求。它告诉缓存系统是否可以使用缓存来响应这个请求，或者是否需要直接从服务器获取资源。</p><p>例如，如果请求头中包含 Cache-Control: no-cache，这告诉所有缓存系统（包括浏览器缓存和代理服务器缓存）在返回资源之前，必须向原始服务器验证资源的有效性，即使资源在缓存中未过期。</p><h4 id="response-cache-control"><a class="header-anchor" href="#response-cache-control">#</a> response cache-control</h4><p>response cache-control 是由服务器在响应客户端请求时设置的，用于指示客户端或中间缓存如何缓存该响应。它告诉缓存系统资源可以缓存多久，以及如何验证缓存的有效性。</p><p>例如，如果响应头中包含 Cache-Control: max-age=3600，这告诉客户端和中间缓存系统该资源可以缓存 3600 秒，在这段时间内，客户端可以直接从缓存中获取资源，而无需再次向服务器请求。</p><h4 id="关系"><a class="header-anchor" href="#关系">#</a> 关系</h4><p>‌<strong>相互影响</strong> ‌：request cache-control 和 response cache-control 相互影响。客户端的请求缓存控制指令可以影响缓存系统是否使用缓存响应请求，而服务器的响应缓存控制指令则决定了资源在客户端和中间缓存系统中的缓存行为。<br><strong>优先级</strong> ：在某些情况下，客户端的请求缓存控制指令可能会覆盖服务器的响应缓存控制指令。例如，即使服务器指示资源可以缓存很长时间，但客户端的请求中包含了 Cache-Control: no-cache，那么缓存系统仍然会向服务器验证资源的有效性。 ‌<strong>共同决定缓存行为</strong> ‌：request cache-control 和 response cache-control 共同决定了资源在客户端和中间缓存系统中的缓存行为。它们通过不同的指令和参数来精细控制缓存的有效期、验证机制等。</p><h3 id="markdown-使用指南"><a class="header-anchor" href="#markdown-使用指南">#</a> MarkDown 使用指南</h3><ul><li><a href="../blog-daily/use-markdown">MarkDown</a> <span style="color:#bbb;float:right;">2021-06-24</span></li></ul>',11),b={render:function(e,r){const o=(0,l.up)("OutboundLink");return(0,l.wg)(),(0,l.j4)(l.HY,null,[a,n,(0,l.Wm)("ul",null,[(0,l.Wm)("li",null,[(0,l.Wm)("p",null,[(0,l.Wm)("a",t,[c,(0,l.Wm)(o)]),s,h])]),(0,l.Wm)("li",null,[(0,l.Wm)("p",null,[(0,l.Wm)("a",p,[i,(0,l.Wm)(o)]),m,u])]),(0,l.Wm)("li",null,[(0,l.Wm)("p",null,[(0,l.Wm)("a",d,[g,(0,l.Wm)(o)])])])]),k],64)}}}}]);